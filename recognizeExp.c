/* recognizeExp.c, Gerard Renardel, 29 January 2014
 *
 * In this file a recognizer acceptExpression is definined that can recognize 
 * arithmetical expressions generated by the following BNF grammar:
 *
 * <expression>  ::= <term> { '+'  <term> | '-' <term> }
 * 
 * <term>       ::= <factor> { '*' <factor> | '/' <factor> }
 *
 * <factor>     ::= <number> | <identifier> | '(' <expression> ')'
 *
 * Input for the recognizer is the token list constructed by the scanner (in scanner.c). 
 * For the recognition of a token list the method of *recursive descent* is used. 
 * It relies on the use of three functions for the recognition and processing of
 * terms, factors and expressions, respectively. 
 * These three functions are defined with mutual recursion, corresponding with the 
 * structure of the BNF grammar.
 */

#include <stdio.h>  /* getchar, printf */
#include <stdlib.h> /* NULL */
#include "scanner.h"
#include "recognizeExp.h"
#include <string.h>
#include "prefixExp.h"

void solve(List *lp);

void evalTerm(List *lp, double *nat, double *iden, int minus);

void evalExpression(List *lp, double *nat, double *iden);

/* The functions acceptNumber, acceptIdentifier and acceptCharacter have as
 * (first) argument a pointer to an token list; moreover acceptCharacter has as
 * second argument a character. They check whether the first token
 * in the list is a number, an identifier or the given character, respectively.
 * When that is the case, they yield the value 1 and the pointer points to the rest of
 * the token list. Otherwise they yield 0 and the pointer remains unchanged.
 */

int acceptNumber(List *lp) {
	if (*lp != NULL && (*lp)->tt == Number) {
		*lp = (*lp)->next;
		return 1;
	}
	return 0;
}

int acceptIdentifier(List *lp) {
  if (*lp != NULL && (*lp)->tt == Identifier) {
	*lp = (*lp)->next;
	return 1;
  }
  return 0;
}

int acceptCharacter(List *lp, char c) {
  if (*lp != NULL && (*lp)->tt == Symbol && ((*lp)->t).symbol == c) {
	//next line changes the current position in the list
	*lp = (*lp)->next;
	return 1;
  }
  return 0;
}

/* The functions acceptFactor, acceptTerm and acceptExpression have as 
 * argument a pointer to a token list. They check whether the token list 
 * has an initial segment that can be recognized as factor, term or expression, respectively.
 * When that is the case, they yield the value 1 and the pointer points to the rest of
 * the token list. Otherwise they yield 0 and the pointer remains unchanged.
 */
 
int acceptTerm(List *lp) {
//	natnum | identifier | natnum identiefier | natnum identifier ^ natnum
//	We also need to accept terms starting with an identifier.
	if(acceptNumber(lp)){
		if(acceptIdentifier(lp)){
			if(acceptCharacter(lp, '^')){
				if(*lp == NULL || (*lp)->tt != Number || acceptCharacter(lp,'-')){
//					printf("returning 0\n");
					return 0;
				} else {
					acceptNumber(lp);
				}
				return 1;
			}
			return 1;
		}
		return 1;
	} else if (acceptIdentifier(lp)) {
		if (acceptCharacter(lp, '^')) {
//			printf("found dakje\n");
			if (*lp == NULL || (*lp)->tt != Number || acceptCharacter(lp,'-')) {
//				printf("returning 0\n");
				return 0;
			} else{
				acceptNumber(lp);
			}
			return 1;
		}
		return 1;
	}
	return 0;
}
// An equation needs to have the following: only one equal sign and two valid expressions.
int acceptEquation(List *lp, List *lp1){
//	if(!isDegree(lp1))
//		return 0;
	if(!acceptExpression(lp)) {
//		printf("!acceptExpression 2\n");
		return 0;
	}
//	printList(*lp);
	if(!acceptCharacter(lp, '=')) {
//		printf("!accept '=' \n");
		return 0;
	}
	if(!acceptExpression(lp)) {
//		printf("!acceptExpression 2\n");
		return 0;
	}
	if(*lp != NULL) {
//		printf("lp != empty");
			return 0;
	}

	return 1;
}
 /* <prefexp>   ::= <number> | <identifier> | '+' <prefexp> <prefexp> | '-' <prefexp> <prefexp> | '*' <prefexp> <prefexp> | '/' <prefexp> <prefexp> 
 * 
 * <number>      ::= <digit> { <digit> }
 *
 * <identifier> ::= <letter> { <letter> | <digit> }
	*/
// An expression is of the following grammar: term | - term | + term
// A term can be followed by a multiple of terms.
int acceptExpression(List *lp) {
//	- term | term | + term

	acceptCharacter(lp, '-');
	if(!acceptTerm(lp)){
		return 0;
	}

  while ( acceptCharacter(lp,'+') || acceptCharacter(lp,'-') ) {

	/* Build Expression tree */

	if ( !acceptTerm(lp) ) {
	  return 0;
	}
  } /* no + or -, so we reached the end of the expression */
  return 1;
}

int acceptVariables(List *lp){
    int same = 1, numVar=0;
    List tempList = NULL;
    while ((*lp) != NULL){
        if((*lp)->tt == Identifier){
			++numVar;
            // if we detect a new variable (t.identifier) then copy it by using the built in scanner (new TokenList)
            // and compare it
            if(numVar == 1){
                // if tempList is empty we have found the first variable in the List
//                printf("Found a variable\n");
                tempList = tokenList((*lp)->t.identifier);
            } else {
                // found a new variable
//                printf("Found a new variable\n");
                if(strcmp(tempList->t.identifier, (*lp)->t.identifier) == 0){
                    //they are the same
                    same = 1;
                } else {
                    //they are not
                    same = 0;
                    break;
                }
            }

        }
        (*lp) = (*lp)->next;
    }
    freeTokenList(tempList);
	if(numVar > 0 ){return same;}
	return 0;
}

// First try, does not use dynamic memory allocation and is not using the built tokenList() function to copy
int checkVariables(List *lp){
	int counter = 0;
	//counter2 =0;
	//int varTest = 0;
	//int index =0;
	char cpyString[10000], cpyCheck[10000];
	//have to set the NULL pointer ourselves
	memset(cpyString, '\0', sizeof(cpyString));
	memset(cpyCheck, '\0', sizeof(cpyCheck));
	while((*lp) != NULL){
		
		if((*lp)->tt == Identifier){
			//copy string. When new variable is detected, check if the strings are different
			// in future might need to check the length of the string because matchIdentifier 
			// in scanner.c uses dynamic memory allocation
			
			//Have to make two copys in order to check. 
			//first variable
			if(counter == 0){
				strcpy(cpyCheck, (*lp)->t.identifier);
				strcpy(cpyString, cpyCheck);
//				printf(" |found a new variable: %s |", cpyString);
				counter++;
			}
			//other variables
			if(counter > 0){
				strcpy(cpyString, (*lp)->t.identifier);
				//printf(" |found a new variable: %s |", cpyString);
				//check if different
				if((strcmp(cpyString, cpyCheck) != 0)){
//					printf("this variable is different\n");
					return 0;
				} else {
					//printf("this is the same variable as we had");
				}
			}
		}
		*lp = (*lp)->next;
	}
	return counter;
}

// This function is not needed since we check for this in acceptTerm
int isDegree(List *lp){
	while((*lp) != NULL){
		if(((*lp)->t).symbol == '^'){
			*lp = (*lp)->next;
			if ( *lp == NULL || (*lp)->tt != Number || acceptCharacter(lp,'-')){
				return 0;
			}
		}
		*lp = (*lp)->next;
	}
	return 1;
}

int checkDegree(List *lp){
//	We know that we have a correct equation with 1 variable
//	What happens when we encounter x = 1 or x + x^0 = 1?
	int highest = 1;
	int counter = 0;
	while((*lp) != NULL){
		if (acceptIdentifier(lp)) {
			if ((*lp) != NULL) {
				if (acceptCharacter(lp, '^')){
					// We know that ^ is always followed by a number (because of recognizeEq)
					if (counter == 0) {
						highest = ((*lp)->t).number;
						*lp = (*lp)->next;
					} else {
						// found a new number/power/degree
						if (((*lp)->t).number > highest) {
							highest = ((*lp)->t).number;
						}
						*lp = (*lp)->next;
					}
				}
//				No ^ so degree = 1
				counter = 1;

			}
		} else{
			if((*lp) != NULL) (*lp) = (*lp)->next;
		}

	}	
	printf("%d\n",highest);
	return highest;	
}

int valueNumber(List *lp, double *wp) {
	if (*lp != NULL && (*lp)->tt == Number ) {
		*wp = ((*lp)->t).number;
		*lp = (*lp)->next;
		return 1;
	}
	return 0;
}

double almostZero(double n){
    if (n> -0.0005 && n < 0.0005){
        return 0;
    }
    return n;
}

//The function solve takes a tokenlist. It evaluates the left and right handside of the equation.
// It stores the natural number value and the identifier value (the natnumber in front of the identifier).
// It then calculates the solution of the equation based on these values.

void solve(List *lp) {
	double leftNatNum=0, leftIden=0, rightNatNum=0, rightIden=0;
	evalExpression(lp, &leftNatNum, &leftIden);
//	printf("lefthandside finished. List = ");
//	printList(*lp);

	evalExpression(lp, &rightNatNum, &rightIden);
//	printf("righthandside finished. List = ");
//	printList(*lp);
//	printf("left: %.1fx + %.1f\nright: %.1fx + %.1f\n", leftIden,leftNatNum,rightIden,rightNatNum);

    rightNatNum -= leftNatNum;
    leftIden -= rightIden;

    if(leftIden != 0){
        rightNatNum /= leftIden;
		printf("solution: %.3f", almostZero(rightNatNum));
    } else {
		printf("not solvable");
	}
    printf("\n");


}
void evalExpression(List *lp, double *nat, double *iden){
	while(!acceptCharacter(lp, '=') && *lp != NULL){
//		printf("-EvalExpression-\n");
		if(acceptCharacter(lp, '-')){
			evalTerm(lp, nat, iden, -1);
		} else if (acceptCharacter(lp, '+')){
			evalTerm(lp, nat, iden, 1);
		} else {
//			A term does not have to start with + or -
			evalTerm(lp,nat,iden,1);
		}
	}
}

void evalTerm(List *lp, double *nat, double *iden, int minus){
	int degree;
	double natNum;
	if(!valueNumber(lp, &natNum)){
		natNum = 1;
	} else {
//		printf("value natNum = %f\n", natNum);
	}
	if(acceptIdentifier(lp)){
//		printf("accept Identifier\n");
		if(acceptCharacter(lp,'^')){
			degree = ((*lp)->t).number;
//			printf("degree= %d\n",degree);
			if(*lp != NULL &&  (*lp)->next != NULL && (*lp)->t.symbol != '=') *lp = (*lp)->next;
			if (degree == 0 ){
				*nat += (minus*natNum);
			} else {
				//degree = 1
				*iden += (minus*natNum);
			}
		} else {
//				degree = 1;
			*iden += (minus*natNum);
		}
	} else {
		// only a natNum without following identifier
		*nat += (minus*natNum);
		if(*lp != NULL && (*lp)->next != NULL && (*lp)->t.symbol != '=') *lp = (*lp)->next;

	}

}

void recognizeEquation(){
	char *ar;
	int degree;
	List tl, tl1,tl2;//tl3;
	ar = readInput();
	printf("give an equation: ");
	while (ar[0] != '!'){
		tl = tokenList(ar);
		printList(tl);
		tl1 = tl;
		tl2 = tl;
		if(!acceptEquation(&tl1, &tl2)){
			printf("this is not an equation\n");
		} else {
			printf("this is an equation");
			tl1 = tl;
			if(acceptVariables(&tl1)){
				printf(" in 1 variable of degree ");
				tl1 = tl;
				degree = checkDegree(&tl1);
                tl1 = tl;
				if(degree == 1){
					//solve this equation
                    solve(&tl1);
					freeTokenList(tl1);
				}
			} else {
				printf(", but not in 1 variable\n");
			}
		}
		//check list for number of unique variable chars
		// and check variable degree. The number after character ^
		
//		freeTokenList(tl1);
//		freeTokenList(tl2);
//		freeTokenList(tl3);
		free(ar);
		freeTokenList(tl);
		printf("\ngive an equation: ");
		ar = readInput();
	}
	free(ar);
	printf("good bye\n");
}
